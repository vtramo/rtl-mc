#pragma once

#include "ParserError.h"
#include "PolyhedralSystem.h"
#include "PolyhedralSystemSymbolTable.h"
#include "PolyhedralSystemParser.h"
#include "PolyhedralSystemBaseVisitor.h"

/*!
 * \class PolyhedralSystemBuilderVisitor
 * \brief Visitor class for building a polyhedral system from a parse tree.
 *
 * This class is responsible for traversing the parse tree generated by the ANTLR parser
 * and constructing a polyhedral system, which includes the mapping \f$ [\cdot] \f$ from atomic propositions to powersets
 * the invariant \f$\mathit{Inv}\f$, and the \f$\mathit{Flow}\f$.
 */
class PolyhedralSystemBuilderVisitor final
{
public:

    /*!
     * \brief Constructs a PolyhedralSystemBuilderVisitor with a given symbol table.
     * \param symbolTable The symbol table used for variable resolution.
     */
    explicit PolyhedralSystemBuilderVisitor(PolyhedralSystemSymbolTable& symbolTable);

    /*!
     * \brief Builds a polyhedral system from the given parse tree.
     * \param parseTree The parse tree generated by the ANTLR parser (\c PolyhedralSystemParser).
     * \return The constructed polyhedral system.
     */
    PolyhedralSystem buildPolyhedralSystem(PolyhedralSystemParser::SystemContext* parseTree);

    /*!
     * \brief Checks if any errors were encountered during the parsing process.
     * \return \c true if errors were encountered, \c false otherwise.
     */
    [[nodiscard]] bool hasErrors() const;

     /*!
     * \brief Retrieves the list of errors encountered during the parsing process.
     * \return A vector of ParserError objects.
     */
    [[nodiscard]] const std::vector<ParserError>& errors() const;

private:
    /*!
     * \class PolyhedralSystemVisitor
     * \brief Internal visitor class for traversing the parse tree and constructing the polyhedral system.
     */
    class PolyhedralSystemVisitor final : public PolyhedralSystemBaseVisitor
    {

    public:
        /*!
         * \brief Constructs a PolyhedralSystemVisitor with a given symbol table.
         * \param symbolTable The symbol table used for variable dimension resolution.
         */
        explicit PolyhedralSystemVisitor(PolyhedralSystemSymbolTable& symbolTable);

        std::any visitSystem(PolyhedralSystemParser::SystemContext* ctx) override;
        std::any visitInv(PolyhedralSystemParser::InvContext* ctx) override;
        std::any visitFlow(PolyhedralSystemParser::FlowContext* ctx) override;

        std::any visitAtomPowerset(PolyhedralSystemParser::AtomPowersetContext* ctx) override;
        std::any visitAtomPoly(PolyhedralSystemParser::AtomPolyContext* ctx) override;
        std::any visitAtomEmpty(PolyhedralSystemParser::AtomEmptyContext* ctx) override;

        std::any visitPowersetEmptyOrNotEmpty(PolyhedralSystemParser::PowersetEmptyOrNotEmptyContext* ctx) override;
        std::any visitPowersetTrue(PolyhedralSystemParser::PowersetTrueContext* ctx) override;

        std::any visitPolyAtLeastOneConstr(PolyhedralSystemParser::PolyAtLeastOneConstrContext* ctx) override;
        std::any visitPolyTrue(PolyhedralSystemParser::PolyTrueContext* ctx) override;

        std::any visitConstr(PolyhedralSystemParser::ConstrContext* ctx) override;

        std::any visitLinearExpr(PolyhedralSystemParser::LinearExprContext* ctx) override;
        std::any visitIntTimesVar(PolyhedralSystemParser::IntTimesVarContext* context) override;
        std::any visitSignTerm(PolyhedralSystemParser::SignTermContext* ctx) override;
        std::any visitVar(PolyhedralSystemParser::VarContext* context) override;
        std::any visitInt(PolyhedralSystemParser::IntContext* context) override;

        /*!
         * \brief Retrieves the denotation mapping \f$ [\cdot] \f$ from atomic propositions to powersets.
         * \return A map from atomic propositions to powersets.
         */
        [[nodiscard]] std::unordered_map<spot::formula, Powerset> getDenotation() const;

        /*!
         * \brief Retrieves the invariant powerset.
         * \return The invariant powerset.
         */
        [[nodiscard]] Powerset getInvariant() const;

        /*!
         * \brief Retrieves the flow polyhedron.
         * \return The flow polyhedron.
         */
        [[nodiscard]] Poly getFlow() const;

        /*!
         * \brief Retrieves the symbol table.
         * \return The symbol table.
         */
        [[nodiscard]] PolyhedralSystemSymbolTable getSymbolTable() const;
        friend class PolyhedralSystemBuilderVisitor;

    private:
        int m_visitKey {}; ///< Key used to track visited nodes.
        std::unordered_map<int, PowersetUniquePtr> m_powersets {};
        std::unordered_map<int, PolyUniquePtr> m_polyhedra {};
        std::unordered_map<int, std::unique_ptr<PPL::Constraint>> m_constraints {};
        std::unordered_map<int, std::unique_ptr<PPL::Linear_Expression>> m_linearExpressions {};

        std::reference_wrapper<PolyhedralSystemSymbolTable> m_symbolTable;
        std::unordered_map<spot::formula, Powerset> m_denotation {};
        Powerset m_invariant {};
        Poly m_flow {};

        std::vector<ParserError> m_errors {};

        bool containsAtom(const spot::formula& atom) const;
        bool containsAtom(std::string_view atom) const;
        void addDuplicateAtomParserError(antlr4::tree::TerminalNode*);
        PolyUniquePtr popPoly(int visitKey);
        PowersetUniquePtr popPowerset(int visitKey);
        std::unique_ptr<PPL::Constraint> popConstraint(int visitKey);
        std::unique_ptr<PPL::Linear_Expression> popLinearExpression(int visitKey);
    };

    PolyhedralSystemVisitor m_visitor;
};