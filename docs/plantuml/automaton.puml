@startuml

/' Objects '/
package automaton {
    class AtomSet {
        --type aliases--
        +using AtomSetHash = std::size_t
        +using AtomSetIterator = std::set<spot::formula>::iterator
        --data members--
        -m_atoms : spot::atomic_prop_set
        -m_hashcode : AtomSetHash
        --constructors--
        +AtomSet()
        +AtomSet(spot::atomic_prop_set&& atomSet)
        +AtomSet(AtomSet&&)
        --member functions--
        +atoms() : spot::atomic_prop_set&
        +containsAtom(const spot::formula& atom) : bool
        +hash() : AtomSetHash
        +size() : int
        +isEmpty() : bool
        +begin() : AtomSetIterator
        +end() : AtomSetIterator
        +toString() : std::string
        --friends--
        +friend struct std::hash<AtomSet>
        --operators--
        +operator!= (const AtomSet& atomSet1, const AtomSet& atomSet2) : bool
        +operator== (const AtomSet& atomSet1, const AtomSet& atomSet2) : bool
        +operator<< (std::ostream& out, const AtomSet& atomSet) : std::ostream&
    }

    class BackwardNFA {
        --type aliases--
        +using EdgeIterator = spot::internal::state_out<spot::digraph<spot::twa_graph_state, spot::twa_graph_edge_data>>
        --data members--
        -m_discreteLtlFormula : DiscreteLtlFormula
        -m_formulaDenotationMap : PolyhedralSystemFormulaDenotationMap
        -m_backwardNfa : spot::twa_graph_ptr
        -m_stateDenotationById : std::unordered_map<int, StateDenotation>
        -m_finalStates : std::unordered_set<int>
        --constructors--
        +BackwardNFA(const DiscreteLtlFormula& discreteLtlFormula, PolyhedralSystemFormulaDenotationMap&& polyhedralSystemLabelDenotationMap, spot::postprocessor::optimization_level optimizationLevel = spot::postprocessor::optimization_level::High, bool anyOption = false)
        +BackwardNFA(DiscreteLtlFormula&& discreteLtlFormula, PolyhedralSystemFormulaDenotationMap&& polyhedralSystemFormulaDenotationMap, spot::postprocessor::optimization_level optimizationLevel = spot::postprocessor::optimization_level::High, bool anyOption = false)
        --member functions--
        +formula() : const DiscreteLtlFormula&
        +predecessors(int state) : EdgeIterator
        +stateDenotation(int state) : const StateDenotation&
        +hasPredecessors(int state) : bool
        +isFinalState(int state) : bool
        +isInitialState(int state) : bool
        +totalEdges() : int
        +totalFinalStates() : int
        +totalStates() : int
        +finalStates() : const std::unordered_set<int>&
        +printDotFormat(std::ostream& os) : void
        +printHoaFormat(std::ostream& os) : void
        -buildAutomaton(const spot::const_twa_graph_ptr& nfa) : void
        -extractStateDenotationFromEdgeGuard(const spot::const_twa_graph_ptr& nfa, const bdd& guard) : StateDenotation
        --operators--
        +operator<< (std::ostream& out, const BackwardNFA& backwardNfa) : std::ostream&
    }

    class PolyhedralSystemFormulaDenotationMap {
        --type aliases--
        -using FormulaToString = std::string;
        -using FormulaId = size_t;
        --data members--
        -m_polyhedralSystem : PolyhedralSystemSharedPtr
        -m_powersetByFormula : std::unordered_map<FormulaId, std::tuple<PowersetConstSharedPtr, FormulaToString>>
        --constructors--
        +PolyhedralSystemFormulaDenotationMap(const PolyhedralSystemSharedPtr& polyhedralSystem)
        +PolyhedralSystemFormulaDenotationMap(PolyhedralSystemFormulaDenotationMap&& other)
        -PolyhedralSystemFormulaDenotationMap() = default
        --member functions--
        +getPolyhedralSystem() : const PolyhedralSystem&
        +getOrComputeDenotation(const spot::formula& formula) : PowersetConstSharedPtr
        +containsDenotation(const spot::formula& formula) : bool
        -computeFormulaDenotation(const spot::formula& formula) : PowersetConstSharedPtr
        -getAtomInterpretation(const spot::formula& formula) : const AtomInterpretation*
        -void saveFormulaDenotation(const spot::formula& formula, PowersetConstSharedPtr denotation) : void
        --operators--
        +operator<< (std::ostream& out, PolyhedralSystemFormulaDenotationMap& polyhedralSystemFormulaDenotationMap) : std::ostream&
    }

    class StateDenotation {
        --data members--
        -m_formula : spot::formula
        -m_powerset : PowersetConstSharedPtr
        -m_isSing : bool
        --constructors--
        +StateDenotation(spot::formula&& formula, PowersetConstSharedPtr powerset, const bool isSing = false)
        +StateDenotation(StateDenotation&& other)
        --member functions--
        +formula() : const spot::formula&
        +denotation() : PowersetConstSharedPtr
        +isSingular() : bool
        +isUniverse() : bool
        +isEmpty() : bool
    }

    struct std::hash<AtomSet> {
        --operators--
        +operator() (const AtomSet* const atomSet) : AtomSetHash
        +operator() (const AtomSet& atomSet) : AtomSetHash
        --static functions--
        +{static} hashCode(const AtomSet* const atomSet) : AtomSetHash
    }
}

class spot::twa_graph_ptr {}
class spot::formula {}

BackwardNFA *--> "1" spot::twa_graph_ptr
BackwardNFA *--> "1" PolyhedralSystemFormulaDenotationMap
BackwardNFA *--> "*" StateDenotation
StateDenotation *--> "1" AtomSet
AtomSet *--> "*" spot::formula
std::hash <...> AtomSet
@enduml
